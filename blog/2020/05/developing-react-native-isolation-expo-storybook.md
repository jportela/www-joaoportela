---
title: Developing React Native components in isolation with Expo and Storybook
description: How to develop your React Native UI components in isolation in a monorepo setup, with Storybook, Expo and Yarn Workspaces
date: '2020-05-22'
tags:
  - React Native
  - Expo
  - Storybook
  - Monorepo
---

Separating the UI components from the application logic promotes a clear separation of concerns, providing easier testing, maintainability and code reuse.

The boundary can be set even further by separating them into different packages. By using a monorepo we take advantage of easier linking, atomic commits (making all changes in one go, instead of having to do several version bumps across different repositories for just one change) and better testing.

Eventually, we can have multiple applications inside the same repository, all using the same component library. This component library, then becomes the source of truth for the [Design System](https://www.invisionapp.com/inside-design/guide-to-design-systems/) of your applications.

The component library can then be developed in isolation, with components being developed and tested (both manually and automatically) by using a tool such as Storybook, which finally allows for publishing of the Design System to the web, for developers, designers or other stakeholders to review and iterate on.

This development workflow is really appealing, and has been used with success [by different companies](https://storybook.js.org/use-cases/).

However, setting this up isn't as easy as it should be. I've been using Expo for a side project and spent almost a week battling bugs and Webpack configuration issues, trying to get it to work.

I was finally able to get it working (_TL;DR_, check https://github.com/jportela/expo-storybook-workspaces), and in this post I'll go through the steps and hurdles along the way.

### Starting with Yarn Workspaces

[Yarn Workspaces](https://classic.yarnpkg.com/en/docs/workspaces/) enables a project to be split into multiple packages, all living under the same repository (the monorepo).

To set it up, create a `package.json` with the following content:

```js
// /package.json
{
  "private": true,
  "workspaces": [
    "packages/*"
  ]
}
```

The `workspaces` field in this example is configured so that every directory inside the `packages` directory will act as a separate package, with its own set of dependencies and `package.json` (you can change this to another parent directory, or even a specific list of directories). Let's create the `packages` directory:

```bash
# /
mkdir packages
```

### Creating the Expo project

Now we'll create the main app, using Expo. Make sure you have the `expo-cli` installed:

```bash
# /
yarn global add expo-cli
```

And create an Expo project. We'll call it `app` for this example:

```bash
# /
expo init packages/app
```

> **Note:** Make sure remove the `.git/` directory under `app/`, since you'll want to commit the root of your monorepo. You'll also need to remove `node_modules` and `yarn.lock`:

```bash
# /packages/app
rm -rf .git/ node_modules/
rm yarn.lock
```

Next we need to make sure the package has a name and a version. Here I'm creating a scoped package `@my`, which allows me to import all the packages in the monorepo using an instantly recognizable scope. Edit your `packages/app/package.json`:

```js
// /packages/app/package.json
  "name": "@my/app",
  "version": "1.0.0",
```

### Setting up Expo to play nicely with Yarn Workspaces

By default Expo doesn't work well with Yarn Workspaces. [The following steps](https://github.com/expo/expo/tree/master/packages/expo-yarn-workspaces) are needed for them to work:

Install `expo-yarn-workspaces` on your `app/`:

```bash
# /packages/app
yarn add -D expo-yarn-workspaces
```

Add the following script (under the `scripts:` property) to `app/package.json`:

```js
// /packages/app/package.json
...
    "postinstall": "expo-yarn-workspaces postinstall"
...
```

And change the `main` entrypoint, to one that will be generated by `expo-yarn-workspaces` (you can choose whatever file name/location for this. Here I've chosen to generate it to the `.expo` directory, since it won't be committed to Git):

```js
// /packages/app/package.json
...
  "main": ".expo/__generated__/AppEntry.js",
...
```

Create a `metro.config.js` file, that contains the following configuration:

```js
// /packages/app/metro.config.js
const { createMetroConfiguration } = require('expo-yarn-workspaces')

module.exports = createMetroConfiguration(__dirname)
```

And finally you need to declare that you want to use that custom Metro configuration on `app.json`:

```js
// /packages/app/app.json
"packagerOpts": {
  "config": "metro.config.js"
}
```

Run `yarn postinstall` (to generate the `.expo/__generated__/AppEntry.js` declared above) and finally test if everything is working properly:

```bash
# /packages/app
yarn postinstall
expo web
```

### Setting up the shared UI library

Now that we have an application up and running, we'll setup the package where the shared UI components will live. We'll call it `ui`:

```bash
# /
mkdir packages/ui
```

Add create the `package.json` for it:

```js
// /packages/ui/package.json
{
  "name": "@my/ui",
  "version": "1.0.0",
  "main": "src/index.tsx"
}
```

Create a component for testing purposes (on the example, I've created a `PrimaryButton` on `src/buttons/primary.tsx`):

```js
// /packages/ui/src/buttons/primary.tsx
import React from 'react'
import { Button } from 'react-native'

interface ButtonProps {
  title: string;
  onPress?: () => void;
}

const emptyFunction = () => {}

export default function PrimaryButton({ title, onPress }: ButtonProps) {
  return (
    <Button
      title={title}
      onPress={onPress || emptyFunction}
      color="lightsalmon"
    />
  )
}
```

### Adding Storybook for testing the component

Storybook is the tool that powers the isolated development workflow for UI components. In order to test if the component works as expected, we'll add Storybook as a dev dependency of `@my/ui`.

Another valid option would be to create another package to contain Storybook, but I personally consider it to be an integral part of developing the `@my/ui` library, so I'm keeping it there.

To add Storybook [I followed the official guide for manually installing it](https://storybook.js.org/docs/guides/guide-react/#manual-setup). First add the needed dependencies, as `devDependencies`.

```bash
# /packages/ui
yarn add -D @storybook/react @babel/core  babel-loader
```

Then add `react`, `react-dom` and `react-native-web`, using the same versions as the app (check `/packages/app/package.json`), in order to avoid issues (using an API that has changed between versions, for example). Note that we are adding them as `devDependencies` instead of `dependencies`. That's because we don't want them to be included and instantiated when @my/app` imports the library. Instead, we are only using them for developing the UI library itself.

```bash
# /packages/ui
yarn add -D react@16.9.0 react-dom@16.9.0 react-native-web@0.11.7
```

Finally we'll add the `.storybook/main.js` configuration file, to specify where stories will live:

```js
// /packages/ui/.storybook/main.js

module.exports = {
  stories: ['../src/**/*.stories.tsx'],
}
```

Notice that with this configuration it's possible to locate the stories in the same directories as the components. That's intentional, as it promotes easier maintainability (ie: if the story is right there, it's easier to update it when the component changes) and documentation for developers (as they provide examples of usage).

### Configure Storybook to support Expo modules

Expo provides a Webpack configuration that makes it easy to import React Native modules in Storybook, through the `@expo/webpack-config` module. First install it:

```bash
# /packages/ui
yarn add -D @expo/webpack-config
```

And then add the following `webpack.config.js`, that Storybook will use:

```js
// /packages/ui/.storybook/webpack.config.js
const { resolve } = require('path')
const { withUnimodules } = require('@expo/webpack-config/addons')

module.exports = ({ config }) => {
  return withUnimodules(config, {
    projectRoot: resolve(__dirname, '../'),
  })
}
```

### Add the Storybook script and try it out

Add the following script to `package.json`:

```js
// /packages/ui/package.json
  "scripts": {
    "storybook": "start-storybook"
  }
```

And run it:

```bash
# /packages/ui
yarn storybook
```

You should see the following:

![Example running in Storybook](storybook.png 'Fig. 1. You can now develop your UI in isolation, outside the app!')

### Import the component in the app

Finally we need to import `@my/ui` in `@my/app`. That's the whole point, since it's where it's going to be used.

Add the package to its dependencies:

```bash
# /packages/app
yarn add @my/ui@1.0.0
```

We need to specify the version number (`@1.0.0`), or else Yarn will try to download a `@my/ui` library that exists on the remote NPM registry, instead of the one on your workspace.

Then import it on `App.tsx`:

```jsx
// /packages/app/App.tsx
import React from 'react'
import { StyleSheet, Text, View } from 'react-native'
import { PrimaryButton } from '@my/ui'

export default function App() {
  return (
    <View style={styles.container}>
      <Text>Open up App.tsx to start working on your app!</Text>
      <PrimaryButton title="Hello, world!" />
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
})
```

And finally run the example using expo:

```bash
# /packages/app
yarn expo start
```

### Wrapping up

To be done
